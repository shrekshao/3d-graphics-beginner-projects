var O=Object.defineProperty;var _=(c,e,t)=>e in c?O(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var x=(c,e,t)=>(_(c,typeof e!="symbol"?e+"":e,t),t);import{u as d,v as G,w,x as A,y as N,i as M,q as F,z as P,j as L,A as y,f as C,m as V}from"./quat.b941390c.js";class B{constructor(e){this.device=e,this.sampler=e.createSampler({minFilter:"linear"}),this.pipelines={}}getMipmapPipeline(e){let t=this.pipelines[e];return t||(this.mipmapShaderModule||(this.mipmapShaderModule=this.device.createShaderModule({code:`
            var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
              vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

            struct VertexOutput {
              @builtin(position) position : vec4<f32>,
              @location(0) texCoord : vec2<f32>,
            };

            @vertex
            fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
              var output : VertexOutput;
              output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
              output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
              return output;
            }

            @group(0) @binding(0) var imgSampler : sampler;
            @group(0) @binding(1) var img : texture_2d<f32>;

            @fragment
            fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
              return textureSample(img, imgSampler, texCoord);
            }
          `})),t=this.device.createRenderPipeline({layout:"auto",vertex:{module:this.mipmapShaderModule,entryPoint:"vertexMain"},fragment:{module:this.mipmapShaderModule,entryPoint:"fragmentMain",targets:[{format:e}]}}),this.pipelines[e]=t),t}generateMipmap(e,t){const n=this.getMipmapPipeline(t.format);if(t.dimension=="3d"||t.dimension=="1d")throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let r=e;const u=t.size.depthOrArrayLayers||1,p=t.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!p){const a={size:{width:Math.ceil(t.size.width/2),height:Math.ceil(t.size.height/2),depthOrArrayLayers:u},format:t.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:t.mipLevelCount-1};r=this.device.createTexture(a)}const f=this.device.createCommandEncoder({}),i=n.getBindGroupLayout(0);for(let a=0;a<u;++a){let s=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:a,arrayLayerCount:1}),m=p?1:0;for(let l=1;l<t.mipLevelCount;++l){const h=r.createView({baseMipLevel:m++,mipLevelCount:1,dimension:"2d",baseArrayLayer:a,arrayLayerCount:1}),b=f.beginRenderPass({colorAttachments:[{view:h,loadOp:"clear",storeOp:"store"}]}),R=this.device.createBindGroup({layout:i,entries:[{binding:0,resource:this.sampler},{binding:1,resource:s}]});b.setPipeline(n),b.setBindGroup(0,R),b.draw(3,1,0,0),b.end(),s=h}}if(!p){const a={width:Math.ceil(t.size.width/2),height:Math.ceil(t.size.height/2),depthOrArrayLayers:u};for(let s=1;s<t.mipLevelCount;++s)f.copyTextureToTexture({texture:r,mipLevel:s-1},{texture:e,mipLevel:s},a),a.width=Math.ceil(a.width/2),a.height=Math.ceil(a.height/2)}return this.device.queue.submit([f.finish()]),p||r.destroy(),e}}const z=1179937895,T={JSON:1313821514,BIN:5130562},k=d(0,0,0),$=G(0,0,0,1),D=d(1,1,1),H=new RegExp(`^${window.location.protocol}`,"i"),X=/^data:/;function I(c,e){return c.match(H)||c.match(X)?c:e+c}class E{constructor(e){x(this,"min",d(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE));x(this,"max",d(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE));e&&(w(this.min,e.min),w(this.max,e.max))}union(e){A(this.min,this.min,e.min),N(this.max,this.max,e.max)}transform(e){const t=[[this.min[0],this.min[1],this.min[2]],[this.min[0],this.min[1],this.max[2]],[this.min[0],this.max[1],this.min[2]],[this.min[0],this.max[1],this.max[2]],[this.max[0],this.min[1],this.min[2]],[this.max[0],this.min[1],this.max[2]],[this.max[0],this.max[1],this.min[2]],[this.max[0],this.max[1],this.max[2]]];M(this.min,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),M(this.max,Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE);for(const n of t)F(n,n,e),A(this.min,this.min,n),N(this.max,this.max,n)}get center(){return d((this.max[0]+this.min[0])*.5,(this.max[1]+this.min[1])*.5,(this.max[2]+this.min[2])*.5)}get radius(){return P(this.max,this.min)*.5}}function S(c,e,t){if(!e.worldMatrix){if(e.matrix?e.worldMatrix=y(e.matrix):(e.worldMatrix=L(),C(e.worldMatrix,e.rotation,e.translation,e.scale),e.localMatrix=y(e.worldMatrix)),V(e.worldMatrix,t,e.worldMatrix),"mesh"in e){const n=c.meshes[e.mesh];if(!n.aabb){n.aabb=new E;for(const r of n.primitives)n.aabb.union(c.accessors[r.attributes.POSITION])}e.aabb=new E(n.aabb),e.aabb.transform(e.worldMatrix)}if(e.children)for(const n of e.children){const r=c.nodes[n];S(c,r,e.worldMatrix),r.aabb&&(e.aabb?e.aabb.union(r.aabb):e.aabb=new E(r.aabb))}}}class g{constructor(){x(this,"loadImageSlots")}async loadFromUrl(e){const t=e.lastIndexOf("/"),n=t!==0?e.substring(0,t+1):"",r=await fetch(e);if(e.endsWith(".gltf"))return this.loadFromJson(await r.json(),n);if(e.endsWith(".glb"))return this.loadFromBinary(await r.arrayBuffer(),n);throw new Error("Unrecognized file extension")}async loadFromBinary(e,t){const n=new DataView(e,0,12),r=n.getUint32(0,!0),u=n.getUint32(4,!0),p=n.getUint32(8,!0);if(r!=z)throw new Error("Invalid magic string in binary header.");if(u!=2)throw new Error("Incompatible version in binary header.");let f={},i=12;for(;i<p;){const m=new DataView(e,i,8),l=m.getUint32(0,!0),h=m.getUint32(4,!0);f[h]=e.slice(i+8,i+8+l),i+=l+8}if(!f[T.JSON])throw new Error("File contained no json chunk.");const s=new TextDecoder("utf-8").decode(f[T.JSON]);return this.loadFromJson(JSON.parse(s),t,f[T.BIN])}async loadFromJson(e,t,n=null){var f;if(!t)throw new Error("baseUrl must be specified.");if(!e.asset)throw new Error("Missing asset description.");if(e.asset.minVersion!="2.0"&&e.asset.version!="2.0")throw new Error("Incompatible asset version.");for(const i of e.accessors)i.byteOffset=i.byteOffset??0,i.normalized=i.normalized??!1;for(const i of e.bufferViews)i.byteOffset=i.byteOffset??0;for(const i of e.nodes)i.matrix||(i.rotation=i.rotation??$,i.scale=i.scale??D,i.translation=i.translation??k);if(e.samplers)for(const i of e.samplers)i.wrapS=i.wrapS??o.REPEAT,i.wrapT=i.wrapT??o.REPEAT;const r=[];if(n)r.push(Promise.resolve(n));else for(const i in e.buffers){const a=e.buffers[i],s=I(a.uri,t);r[i]=fetch(s).then(m=>m.arrayBuffer())}let u;if(this.loadImageSlots){u=new Set;for(const i of e.materials)for(const a of this.loadImageSlots){const s=i[a]??i.pbrMetallicRoughness[a];s!==void 0&&u.add(e.textures[s.index].source)}}const p=[];for(let i=0;i<((f=e.images)==null?void 0:f.length);++i){if(u&&!u.has(i))continue;const a=e.images[i];if(a.uri)p[i]=fetch(I(a.uri,t)).then(async s=>createImageBitmap(await s.blob()));else{const s=e.bufferViews[a.bufferView];p[i]=r[s.buffer].then(m=>{const l=new Blob([new Uint8Array(m,s.byteOffset,s.byteLength)],{type:a.mimeType});return createImageBitmap(l)})}}for(const i of Object.values(e.scenes))for(const a of i.nodes){const s=e.nodes[a];S(e,s,L()),s.aabb&&(i.aabb?i.aabb.union(s.aabb):i.aabb=new E(s.aabb))}return e.buffers=await Promise.all(r),e.images=await Promise.all(p),e}static componentCountForType(e){switch(e){case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":return 4;case"MAT4":return 16;default:return 0}}static sizeForComponentType(e){switch(e){case o.BYTE:return 1;case o.UNSIGNED_BYTE:return 1;case o.SHORT:return 2;case o.UNSIGNED_SHORT:return 2;case o.UNSIGNED_INT:return 4;case o.FLOAT:return 4;default:return 0}}static packedArrayStrideForAccessor(e){return g.sizeForComponentType(e.componentType)*g.componentCountForType(e.type)}}const o=WebGLRenderingContext;function U(c){switch(c){case o.CLAMP_TO_EDGE:return"clamp-to-edge";case o.MIRRORED_REPEAT:return"mirror-repeat";default:return"repeat"}}function J(c,e,t,n){if(!n)return null;const r=c.createBuffer({label:e.name,size:Math.ceil(e.byteLength/4)*4,usage:n,mappedAtCreation:!0});return new Uint8Array(r.getMappedRange()).set(new Uint8Array(t,e.byteOffset,e.byteLength)),r.unmap(),r}function v(c,e={name:"glTF default sampler"}){const t={label:e.name,addressModeU:U(e.wrapS),addressModeV:U(e.wrapT)};switch((!e.magFilter||e.magFilter==o.LINEAR)&&(t.magFilter="linear"),e.minFilter){case o.NEAREST:break;case o.LINEAR:case o.LINEAR_MIPMAP_NEAREST:t.minFilter="linear";break;case o.NEAREST_MIPMAP_LINEAR:t.mipmapFilter="linear";break;case o.LINEAR_MIPMAP_LINEAR:default:t.minFilter="linear",t.mipmapFilter="linear";break}return c.createSampler(t)}function W(c,e,t){const n=Math.floor(Math.log2(Math.max(e.width,e.height)))+1,r={size:{width:e.width,height:e.height},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:n},u=c.createTexture(r);return c.queue.copyExternalImageToTexture({source:e},{texture:u},r.size),t.generateMipmap(u,r),u}class K extends g{constructor(e){super(),this.device=e,this.mipmapGenerator=new B(e),this.defaultSampler=v(e)}async loadFromJson(e,t,n){var i;const r=await super.loadFromJson(e,t,n),u=this.device,p=[];function f(a,s){const m=r.accessors[a];p[m.bufferView]|=s}for(const a of r.meshes)for(const s of a.primitives){"indices"in s&&f(s.indices,GPUBufferUsage.INDEX);for(const m of Object.values(s.attributes))f(m,GPUBufferUsage.VERTEX)}if(r.skins)for(const a of r.skins)f(a.inverseBindMatrices,GPUBufferUsage.STORAGE);r.gpuBuffers=[];for(const[a,s]of Object.entries(r.bufferViews))r.gpuBuffers[a]=J(u,s,r.buffers[s.buffer],p[a]);if(r.gpuTextures=[],(i=r.images)!=null&&i.length){const a=[];if(r.images)for(const[m,l]of Object.entries(r.images))l&&(a[m]=W(u,l,this.mipmapGenerator));const s=[];if(r.samplers)for(const[m,l]of Object.entries(r.samplers))s[m]=v(u,l);if(r.textures)for(const[m,l]of Object.entries(r.textures)){const h=a[l.source];h&&(r.gpuTextures[m]={texture:h,sampler:l.sampler?s[l.sampler]:this.defaultSampler})}}return r.gpuDefaultSampler=this.defaultSampler,r}static gpuFormatForAccessor(e){const t=e.normalized?"norm":"int",n=g.componentCountForType(e.type),r=n>1?`x${n}`:"";switch(e.componentType){case o.BYTE:return`s${t}8${r}`;case o.UNSIGNED_BYTE:return`u${t}8${r}`;case o.SHORT:return`s${t}16${r}`;case o.UNSIGNED_SHORT:return`u${t}16${r}`;case o.UNSIGNED_INT:return`u${t}32${r}`;case o.FLOAT:return`float32${r}`}}static gpuPrimitiveTopologyForMode(e){switch(e){case o.TRIANGLES:return"triangle-list";case o.TRIANGLE_STRIP:return"triangle-strip";case o.LINES:return"line-list";case o.LINE_STRIP:return"line-strip";case o.POINTS:return"point-list"}}static gpuIndexFormatForComponentType(e){switch(e){case o.UNSIGNED_SHORT:return"uint16";case o.UNSIGNED_INT:return"uint32";default:return 0}}}export{E as AABB,g as TinyGltf,K as TinyGltfWebGpu};
