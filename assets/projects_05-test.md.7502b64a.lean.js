import{_ as oe}from"./chunks/gpu-canvas.vue_vue_type_script_setup_true_lang.4f2e62a7.js";import{p as ue,a1 as v,d as fe,c as ce,C as de,b as le,x as z,a as pe,o as me}from"./chunks/framework.9695c624.js";import{c as R,s as he,a as be,b as xe,p as Ee,f as ye,m as Be,g as Se,l as Me,h as ge,i as Te,j as _e}from"./chunks/quat.eb419a7f.js";const Oe=ue("/gltf/di-player-test-hair-rig.glb"),Pe={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16};async function Ae(m,s){const U=(await v(()=>import("./chunks/orbitCamera.49e28956.js"),["assets/chunks/orbitCamera.49e28956.js","assets/chunks/quat.eb419a7f.js"])).default,{TinyGltf:Y,AABB:J}=await v(()=>import("./chunks/tiny-gltf.51cc1fa0.js"),["assets/chunks/tiny-gltf.51cc1fa0.js","assets/chunks/quat.eb419a7f.js"]),S=[];class X{constructor(u,i){this.nodeIdx2JointIdx={};const n=i.joints.length;this.jointMatrices=new Float32Array(16*n);for(const[a,f]of i.joints.entries())this.jointMatrices.set(u.nodes[f].worldMatrix,16*a),this.nodeIdx2JointIdx[f]=a;const t=64*n;this.inverseBindMatricesStaticBuffer=s.createBuffer({label:"Skin inverseBindMatricesStaticBuffer",size:t,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.jointMatricesDynamicBuffer=s.createBuffer({label:"Skin jointMatricesDynamicBuffer",size:t,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});{const a=u.accessors[i.inverseBindMatrices],f=u.bufferViews[a.bufferView];s.queue.writeBuffer(this.inverseBindMatricesStaticBuffer,0,u.buffers[f.buffer],f.byteOffset+(a.byteOffset??0),f.byteLength)}this.updateJointMatricesDynamicBuffer(),this.bindGroup=s.createBindGroup({label:"Static Storage Bind Group",layout:N,entries:[{binding:0,resource:{buffer:this.inverseBindMatricesStaticBuffer}},{binding:1,resource:{buffer:this.jointMatricesDynamicBuffer}}]})}updateJointMatricesDynamicBuffer(){s.queue.writeBuffer(this.jointMatricesDynamicBuffer,0,this.jointMatrices.buffer)}}const M=[],g=[],T=navigator.gpu.getPreferredCanvasFormat();m.configure({device:s,format:T,alphaMode:"opaque"});const q=s.createTexture({size:[m.canvas.width,m.canvas.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT}),h=new U(m.canvas),b=await new Y().loadFromUrl(Oe),x=new J({min:new Float32Array([-2.878838062286377,-.021465064957737923,-3.228097915649414]),max:new Float32Array([2.8631608486175537,11.281305313110352,3.417842388153076])});console.log(b),h.target=x.center,h.maxDistance=x.radius*8,h.minDistance=x.radius*.25,h.distance=x.radius*2.5;const W=x.radius*4,C=Float32Array.BYTES_PER_ELEMENT*36,E=new ArrayBuffer(C),H=new Float32Array(E,0,16),Z=new Float32Array(E,16*Float32Array.BYTES_PER_ELEMENT,16),$=new Float32Array(E,32*Float32Array.BYTES_PER_ELEMENT,3),K=new Float32Array(E,35*Float32Array.BYTES_PER_ELEMENT,1),V=s.createBuffer({size:C,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),_=s.createBindGroupLayout({label:"Frame BindGroupLayout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{}}]}),Q=s.createBindGroup({label:"Frame BindGroup",layout:_,entries:[{binding:0,resource:{buffer:V}}]}),y=s.createBuffer({size:4*1024*1024,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),B=s.createBuffer({size:34064,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0}),O=s.createBuffer({size:4*1024*1024,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),P=s.createBindGroupLayout({label:"Static Storage Bind Group",entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]}),N=s.createBindGroupLayout({label:"Skin Storage Bind Group",entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]}),A=R(),I=R(),p=R();class ee{constructor(u,i,n){this.channels=[];function t(a){const f=u.accessors[a],e=u.bufferViews[f.bufferView];return new Float32Array(u.buffers[e.buffer],e.byteOffset+(f.byteOffset??0),e.byteLength/4)}this.skin=n;for(const a of i.channels){const f=a.target.node,e=i.samplers[a.sampler],r={input:t(e.input),output:t(e.output),outputCount:Pe[u.accessors[e.output].type],idx:0,endT:0,inputMax:0};r.endT=r.input[r.input.length-1],r.inputMax=r.endT-r.input[0];const c={nodeIdx:f,jointIdx:n.nodeIdx2JointIdx[f],target:a.target.path,sampler:r};this.channels.push(c)}}parseNode(u,i){const n=b.nodes[u];if(ye(n.localMatrix,n.rotation,n.translation,n.scale),Be(n.worldMatrix,i,n.localMatrix),u in this.skin.nodeIdx2JointIdx){const t=this.skin.nodeIdx2JointIdx[u];this.skin.jointMatrices.set(n.worldMatrix,16*t)}if(n.children)for(const t of n.children)this.parseNode(t,n.worldMatrix)}update(u){for(const i of this.channels){let n=u;const t=i.sampler,a=b.nodes[i.nodeIdx][i.target];a||console.error("Unsupported animation channel target ",i.target);const f=t.input.length;if(f>1){for(n>t.endT&&(n-=t.inputMax*Math.ceil((n-t.endT)/t.inputMax),t.idx=0);t.idx<=f-2&&n>=t.input[t.idx+1];)t.idx++;t.idx>=f-1&&(n-=t.inputMax,t.idx=0);const e=t.idx,r=e*t.outputCount,c=r+t.outputCount,l=Math.max(0,n-t.input[e])/(t.input[e+1]-t.input[e]);for(let d=0;d<t.outputCount;d++)A[d]=t.output[r+d],I[d]=t.output[c+d];t.outputCount===4?Se(p,A,I,l):Me(p,A,I,l)}else{n=t.input[0],t.idx=0;for(let e=0;e<t.outputCount;e++)p[e]=t.output[e]}t.outputCount===4?ge(a,p):Te(a,p[0],p[1],p[2])}for(const i of b.scenes[0].nodes)this.parseNode(i,_e());this.skin.updateJointMatricesDynamicBuffer()}}function te(o){function u(e){return{curOffset:0,mapped:new Uint8Array(e.getMappedRange())}}function i(e,r){const c=o.accessors[r],l=o.bufferViews[c.bufferView];e.mapped.set(new Uint8Array(o.buffers[l.buffer],l.byteOffset+(c.byteOffset??0),l.byteLength),e.curOffset);const d=e.curOffset;return e.curOffset+=l.byteLength,{offset:d,size:l.byteLength}}if(o.skins){for(const[e,r]of o.skins.entries())M.push(new X(o,r));if(o.animations){const e=o.animations[20];console.log(e),w=new ee(o,e,M[0])}}const n={curOffset:0,mapped:new Float32Array(O.getMappedRange())};let t=0;for(const e of o.nodes)"mesh"in e&&("skin"in e&&(o.meshes[e.mesh].skin=e.skin),n.mapped.set(e.worldMatrix,n.curOffset),n.curOffset+=16,o.meshes[e.mesh].nodeIdx=t++);const a=u(y),f=u(B);for(const e of o.meshes)for(const r of e.primitives){"indices"in r||console.error("Unsupported: gltf model mesh does not have indices");const c=o.accessors[r.indices],l=WebGLRenderingContext;(c.type!=="SCALAR"||c.componentType!==l.UNSIGNED_SHORT)&&console.error("Unsupported index type: ",c);const d=i(f,r.indices),j=o.accessors[r.indices].count;if("POSITION"in r.attributes||console.error("Unsupported: gltf model mesh primitive has no POSITION attribute"),"NORMAL"in r.attributes||console.error("Unsupported: gltf model mesh primitive has no NORMAL attribute"),"TEXCOORD_0"in r.attributes||console.error("Unsupported: gltf model mesh primitive has no TEXCOORD_0 attribute"),e.skin!==void 0){const L={skinIdx:e.skin,vertexBuffers:[i(a,r.attributes.POSITION),i(a,r.attributes.NORMAL),i(a,r.attributes.TEXCOORD_0),i(a,r.attributes.JOINTS_0),i(a,r.attributes.WEIGHTS_0)],indexOffset:d.offset,indexSize:d.size,drawIndexedCount:j,instanceCount:1,firstInstance:e.nodeIdx};g.push(L)}else{const L={vertexBuffers:[i(a,r.attributes.POSITION),i(a,r.attributes.NORMAL),i(a,r.attributes.TEXCOORD_0)],indexOffset:d.offset,indexSize:d.size,drawIndexedCount:j,instanceCount:1,firstInstance:e.nodeIdx};S.push(L)}}g.sort((e,r)=>e.skinIdx-r.skinIdx)}let w;te(b),y.unmap(),B.unmap(),O.unmap();const re=s.createBindGroup({label:"Static Storage Bind Group",layout:P,entries:[{binding:0,resource:{buffer:O}}]}),ne=s.createShaderModule({code:he}),ae=s.createShaderModule({code:be}),F=s.createShaderModule({code:xe}),se=s.createRenderPipeline({label:"Static Mesh",layout:s.createPipelineLayout({label:"Static Mesh",bindGroupLayouts:[_,P]}),vertex:{module:ne,entryPoint:"vertexMain",buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{format:"float32x3",offset:0,shaderLocation:0}]},{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{format:"float32x3",offset:0,shaderLocation:1}]},{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{format:"float32x2",offset:0,shaderLocation:2}]}]},primitive:{topology:"triangle-list",cullMode:"back"},multisample:{count:1},depthStencil:{format:"depth24plus",depthWriteEnabled:!0,depthCompare:"less"},fragment:{module:F,entryPoint:"fragmentMain",targets:[{format:T}]}}),ie=s.createRenderPipeline({label:"Skinned Mesh",layout:s.createPipelineLayout({label:"Skinned Mesh",bindGroupLayouts:[_,P,N]}),vertex:{module:ae,entryPoint:"vertexMain",buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{format:"float32x3",offset:0,shaderLocation:0}]},{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{format:"float32x3",offset:0,shaderLocation:1}]},{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{format:"float32x2",offset:0,shaderLocation:2}]},{arrayStride:4*Uint8Array.BYTES_PER_ELEMENT,attributes:[{format:"uint8x4",offset:0,shaderLocation:3}]},{arrayStride:4*Float32Array.BYTES_PER_ELEMENT,attributes:[{format:"float32x4",offset:0,shaderLocation:4}]}]},primitive:{topology:"triangle-list",cullMode:"back"},multisample:{count:1},depthStencil:{format:"depth24plus",depthWriteEnabled:!0,depthCompare:"less"},fragment:{module:F,entryPoint:"fragmentMain",targets:[{format:T}]}});let k=performance.now()*.001,G=0;function D(o){o*=.001;const u=s.createCommandEncoder(),n={colorAttachments:[{view:m.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:q.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}};Ee(H,Math.PI*.5,1,.01,W),Z.set(h.viewMatrix),$.set(h.position),K[0]=G,w&&w.update(G),G+=o-k,k=o,s.queue.writeBuffer(V,0,E);const t=u.beginRenderPass(n);if(t.setBindGroup(0,Q),t.setBindGroup(1,re),S.length>0){t.setPipeline(se);for(const e of S){for(let r=0;r<e.vertexBuffers.length;r++){const c=e.vertexBuffers[r];t.setVertexBuffer(r,y,c.offset,c.size)}t.setIndexBuffer(B,"uint16",e.indexOffset,e.indexSize),t.drawIndexed(e.drawIndexedCount,e.instanceCount,0,0,e.firstInstance)}}t.setPipeline(ie);let a=-1,f;for(const e of g){e.skinIdx!==a&&(a=e.skinIdx,f=M[a],t.setBindGroup(2,f.bindGroup));for(let r=0;r<e.vertexBuffers.length;r++){const c=e.vertexBuffers[r];t.setVertexBuffer(r,y,c.offset,c.size)}t.setIndexBuffer(B,"uint16",e.indexOffset,e.indexSize),t.drawIndexed(e.drawIndexedCount,e.instanceCount,0,0,e.firstInstance)}t.end(),s.queue.submit([u.finish()]),requestAnimationFrame(D)}requestAnimationFrame(D)}const Ie=z("h1",{id:"particles",tabindex:"-1"},[pe("Particles "),z("a",{class:"header-anchor",href:"#particles","aria-label":'Permalink to "Particles"'},"â€‹")],-1),Ce=JSON.parse('{"title":"Particles","description":"","frontmatter":{},"headers":[],"relativePath":"projects/05-test.md"}'),we={name:"projects/05-test.md"},Ve=fe({...we,setup(m){return(s,U)=>(me(),ce("div",null,[Ie,de(oe,{onInit:le(Ae)},null,8,["onInit"])]))}});export{Ce as __pageData,Ve as default};
